import fs from "fs";
import path from "path";

const HEADER = `//! This file was automatically generated by "src/scripts/genotype.mjs".\n//! Do NOT modify this file manually. Any changes will be overwritten.\n`;

const ROOT = process.cwd();
const constantsDir = path.join(ROOT, "src", "constants");
const constantsFile = path.join(constantsDir, "index.ts");
const networksDir = path.join(ROOT, "src", "networks");

function getDirectories(src) {
  return fs
    .readdirSync(src, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name)
    .sort();
}

function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function isValidNetworkName(name) {
  // naming convention: lowercase letters only
  return /^[a-z]+$/.test(name);
}

// No runtime JSON config required; validation relies on type export in index.ts

function validateConfig(network, dir) {
  // Ensure index.ts exports the type alias
  const indexPath = path.join(dir, "index.ts");
  assert(fs.existsSync(indexPath), `Missing index.ts in '${dir}'`);
  const indexContent = fs.readFileSync(indexPath, "utf8");
  // Accept either a direct type alias (with '=') or a type re-export with braces
  const hasAlias = /export\s+type\s+ContractConfig\s*=\s*/.test(indexContent);
  const hasReExport = /export\s+type\s*{\s*ContractConfig\s*}/.test(
    indexContent
  );
  assert(
    hasAlias || hasReExport,
    `Network '${network}' must export 'type ContractConfig' (alias or re-export) from ${indexPath}`
  );
}

// Generate src/constants/index.ts consolidating network types, registry, and contract map
function generateConstantsFile(networks) {
  ensureDir(constantsDir);

  const union = networks.map((n) => `"${n}"`).join(" | ") || "never";
  const arr = networks.map((n) => `"${n}"`).join(", ");
  const registries = networks
    .map((n) => `  ${n}: async () => await import("../networks/${n}"),`)
    .join("\n");
  const mapLines = networks
    .map((n) => `  ${n}: import("../networks/${n}").ContractConfig;`)
    .join("\n");

  const content = `${HEADER}
export type NETWORK_TYPES = ${union};
export const NETWORK_TYPES_ARRAY = [${arr}] as const;

export const REGISTRIES = {
${registries}
};

export type NETWORK_CONTRACT_MAP = {
${mapLines}
};

export type DAppUiProps<N extends NETWORK_TYPES = NETWORK_TYPES> = {
  network: N;
  contract: NETWORK_CONTRACT_MAP[N];
};

export type DAppUiContextType = {
  network: NETWORK_TYPES;
  contract: NETWORK_CONTRACT_MAP[NETWORK_TYPES];
};
`;

  // write without changing permissions; keep file editable in IDE
  if (fs.existsSync(constantsFile)) {
    try {
      fs.chmodSync(constantsFile, 0o644);
    } catch (_) {}
  }
  fs.writeFileSync(constantsFile, content);
  return constantsFile;
}

function ensureHuskyHook() {
  const huskyDir = path.join(ROOT, ".husky");
  ensureDir(huskyDir);
  const hookPath = path.join(huskyDir, "pre-commit");
  const hook = `#!/usr/bin/env sh
. "$(dirname "$0")/_/husky.sh"

pnpm run genotype

# if genotype changed files, fail the commit
if ! git diff --exit-code -- src/constants/index.ts; then
  echo "\nPre-commit: Generated files are out of sync. Please stage updated files and retry."
  exit 1
fi
`;
  fs.writeFileSync(hookPath, hook, { mode: 0o755 });
}

function main() {
  ensureDir(constantsDir);
  if (!fs.existsSync(networksDir)) {
    throw new Error(`Networks directory not found: ${networksDir}`);
  }
  const networks = getDirectories(networksDir);
  // Validation system
  networks.forEach((n) => {
    assert(
      isValidNetworkName(n),
      `Invalid network folder name '${n}'. Use lowercase letters only.`
    );
    const dir = path.join(networksDir, n);
    validateConfig(n, dir);
  });
  const constPath = generateConstantsFile(networks);
  ensureHuskyHook();
  console.log(`Generated constants at: ${constPath}`);
}

main();
